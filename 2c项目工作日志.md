## 周一 0102

### 前端

工作内容：搭建项目，创建注册页面，实现mock的用户添加流程

知识点：

- 搭建项目的流程：vite命令创建新项目文件，选择框架和编程语言，新项目下安装相关依赖

- 页面：使用element-ui，main.js引入样式表，use将elementPlus的内容绑定到vue上

- mock流程下的添加用户请求流程：

  1. config：当前环境，当前环境下的mockBaseUrl和baseUrl（来自后台）

  2. 对于axios的二次封装，创建request类：

     service对象创建

     service绑定请求前和请求后的拦截器，主要用来设置请求头和处理响应拿到的内容

     request封装service，主要是将一些请求属性（比如请求方式，baseUrl，post的params等）整理了之后传给service并返回service

  3. mock拦截器设置：绑定url需要调用的模拟后台方法

  4. 增加用户的api，创建对应的request对象

  5. 绑定该api到具体的组件上

bug：reactive和ref的使用

### 后台

工作内容：连接数据库，实现数据库迁移，User数据表创建，User数据访问接口创建：get查询所有用户，post新增用户

## 周三 0104

### 后台

工作内容：

1. 确定了创建的sim的三类字典`sim_pars`,`int_pars`,`epi_pars`，并且对于传入参数进行了规范
2. 对于参数进行了解析，创建了相应的模拟并运行出结果
3. 确定了请求模拟结果的接口`sim_res`，同时给定了返回数据的json格式

### 前端

工作内容：

1. 设定了请求sim模拟数据的api
2. 创建了工作平台的主页面
3. 使用echart对后台的数据进行了基本的渲染

知识点：echart绘制层叠折线图

基本上来说，掌握了这个字典和其中字段的含义，就可以制作出不同数据下的层叠折线图

1. 配置字典，在vue中属于响应式数据

   ```js
   let Options=reactive({
       //图表标题+标题样式
                    title:{
                       text:"",
                       textStyle: {
                           fontFamily:"宋体",
                           fontWeight: 'bold',
                           color: '#17b3a3'
                           
                       }
                    },
       //图例
                    legend:{
                        //序列名称数组
                           data:['cum_death','cum_critical'],
                           bottom:10,
                           textStyle:{
                           color:"#17b3a3",
                           },  
                       },
       //提示框
                   tooltip:{
                       trigger:'axis'
                   },
       //x轴序列+x轴样式
   
                   xAxis: {
                          
                           data: [],
                           axisLine:{
                               lineStyle:{
                                   color:"#17b3a3"
                               }
                           }
                           },
       //y轴样式
                   yAxis: {
                      
                       axisLine:{
                           lineStyle:{
                               color:"#17b3a3"
                           }
                           }
                       
                   }, 
       //核心数据，每一组序列以对象的形式保存在series中
                   series:[],
               })
   ```

2. series的内容：每一组序列以对象的形式保存在series中，示例如下

   ```js
   series=[
       {
           type:"line",
           name:"cum_death",
           data:[0,0,0,...,0],
       },
       {
           type:"line",
           name:"cum_critical",
           data:[0,0,0,...,0],
       },
   ]
   ```

   通常需要把后台的数据处理成上述的结构，进行保存

3. 在页面上创建图标所对应的元素，元素需要有固定的宽高，并且基于上述配置渲染图表

   ```html
    <div ref="cum_echart" style="height:300px;"></div>
   ```

   ```js
   const cumChart=Echart.init(proxy.$refs["cum_echart"]);
   cumChart.setOption(xOptions);
   ```

   

## 周五 0106

### 前端

工作内容：

1. 设计模型参数表单

知识点：element-ui框架的表单制作、v-model

## 周六 0107

### 前端

工作内容：

1. 通过post表单提交sim_pars数据到后台，根据后台返回的数据实现页面渲染

### 后台

工作内容：

1. 增加了runSim方法`url:/run_sim`，当接收到表单的时候使用，把模型运行的结果返回给前端

## 周一 0116

### 前端

工作内容：

使用了element-ui的骨架组件给图表现实作加载处理

知识点：

基本使用思路

1. 骨架组件通过v-loading决定是否展现加载元素
2. 骨架组件可以插槽自定义一些加载背景
3. 骨架组件设有元素组件，可以用来选择合适的元素作为加载背景

## 周三-周四 0118-0119

### 前端

工作内容：

同一张图表的数据通过按钮请求新的数据从而刷新，在新的图表展示前做一个加载动画

1. 图表声明为响应式的，会导致echart中`tooltip:{trigger:'axis'}`失灵不展示，比较好的处理还是不要将图表声明为响应式

2. 直接把图表在setup中做初始化，会因为页面没有创建dom元素而报错，所以使用钩子`onMounted`，等页面渲染完成在这里做初始化

3. 运行时，要清空上一轮图表的数据，打开加载动画，之后拿到新的数据进行渲染，关闭加载动画，如此反复

4. 加载动画还是选择了element-plus的很多组件自带的loading相关指令，方便好用，同时可以多次调用

   下面是我的解决方案代码示例

   1. 图表容器+loading指令

   ```html
   <el-card shadow="hover" v-loading="loading" element-loading-text="运行中...">
                   <div ref="cum_echart" style="height:300px;">  
                   </div>
   </el-card>
   ```

   2. 运行处理程序

   ```js
   //初始化累计和新增折线图
       let cumChart=null
       let newChart=null
       onMounted(()=>{
           cumChart=Echart.init(proxy.$refs["cum_echart"]);
           newChart=Echart.init(proxy.$refs["new_echart"]);
       })
    const onRun=()=>{
           //清空上一轮页面渲染的内容
           if(cumChart)
               cumChart.clear();
           if(newChart)
               newChart.clear();
          
           //打开加载页面动画，保证用户体验
            loading.value=true
            
           
            proxy.$api.addNewRun(all_pars).then((res)=>{
               //处理请求数据...
        		//使用请求数据渲染...
               //渲染结束后取消加载动画
               loading.value=false;
            }
            )
            
       }
   ```

   ## 周日 0122

   ### 前端

   知识点：把表单中接收到的字符串进行像数字类型的转化

   1. 只接收整数数字：`v-model.number`

   2. 使用函数处理格式（日期转化，正则表达式等）：以小数处理为例

      ```js
      function toFloatNumber(value) { 
          		//已经是数字直接返回
                  if(typeof value==="number")
                  return value;
                  // 清除"数字"和"."以外的字符
                  value = value.replace(/[^\d.]/g,"");
                  // 清除开头的"."
                  value = value.replace(/^\./g,"");
                  // 将超过两位小数以外的数字替换为字符"."
                  value = value.replace(/\.{2,}/g,".");
                  // 除了第一个小数点以后，后面的小数点全部替换为空
                  value = value.replace(".","$#$").replace(/\./g,"").replace("$#$",".");
                  // 只能输入六位小数
                  value = value.replace(/^(\-)*(\d+)\.(\d\d\d\d\d\d).*$/,'$1$2.$3');
                  //如果没有小数点，首位不能为类似于 01、02的数字
                  if(value.indexOf(".")< 0 && value !=""){
                      if(value.substr(0,1) == '0' && value.length == 2){
                          value= value.substr(1,value.length);
                      }
                  }
                  return parseFloat(value)
              }
      
      ```

   3. 处理函数要在参数传递之前转化，后期研究一下`@input`事件绑定函数

   ### 后台

   给sim模型接收了epiPars，同时将在模型中设定了模型的相对感染率，重症率等流行病学概率

   ```py
   beta=epi_pars['beta']
   # 设定相对流行病学参数
       if epi_pars['rel_beta']:
           sim.pars['rel_beta'] = epi_pars['rel_beta']
       sim.pars['rel_symp_prob'] = epi_pars['symp']
       sim.pars['rel_severe_prob'] = epi_pars['severe']
       sim.pars['rel_crit_prob'] = epi_pars['crit']
       sim.pars['rel_death_prob'] = epi_pars['death']
   ```

## 0130-0131

### 完成悲观乐观搭建

   1. 防疫

      - 积极：社区，学校，家庭传播率0.8
      - 消极：无防疫措施

   2. 传播率及疾病各阶段转化概率设定

      仿照covasim-web项目，借用了其中的region字典，保留了下面三种模式，并根据omicron前些阶段的传播率校准情况，将传播率设当调高

      ```py
      regions = {
          'beta': {
              'Default': 0.020,
              'Optimistic': 0.015,
              'Pessimistic': 0.025,
          },
          'rel_symp_prob': {
              'Default': 1.0,
              'Optimistic': 1.2,
              'Pessimistic': 0.5,
          },
          'rel_severe_prob': {
              'Default': 1.0,
              'Optimistic': 0.3,
              'Pessimistic': 3.0,
          },
          'rel_crit_prob': {
              'Default': 1.0,
              'Optimistic': 0.7,
              'Pessimistic': 5.0,
          },
          'rel_death_prob': {
              'Default': 1.0,
              'Optimistic': 0.5,
              'Pessimistic': 2.0,
          },
      }
      ```

      - 默认：Default所对应的数值
      - 乐观：Optimistic所对应的数值
      - 积极：Pessimistic所对应的数值

### 数字看板

选择了五组累计数值对本次模拟的结果进行展示，五组数据分别为：感染，重症，危重，死亡，康复

同时增加了对每日累计康复患者的模拟结果展现

知识点：看板实现的方案

1. 在前端使用响应式的字典，保存每一条数据的特性信息，包括文字颜色，文字标签，数据数值。方便在取得模拟的结果后在页面中循环渲染

   ```js
    const panel = reactive({
           cum_infections:{
               label:"累计感染数量",
               num:0,
               color:"#4266BE",
           },
        ...
   })
   ```

   

2. 设计每条数据的布局样式，以居中分布为主，主要通过flex实现

3. 在`onRun`方法中读取返回的模拟结果，给响应式字典赋值

4. `sim.results['cum_infections'][-1]`中读取序列数据值的最后一个数值，即为最后一天的累计值，作为结果的一部分返回给前端

### echart图表的resize

当浏览器窗口大小变化时，对于echart图表的大小做相应的变化调整

知识点：vue3中的事件监听，图表resize

1. 对于`onMounted`的理解

   - 组件挂载：Vue3中的组件挂载指的是将组件与页面中的 DOM 元素对应起来的过程。在 Vue 中，每个组件都有一个对应的虚拟 DOM，而挂载的过程即是将组件的虚拟 DOM 映射到真实的 DOM 上。在组件挂载完成后，组件可以对页面中的 DOM 元素进行操作，并对用户的交互产生反应。
   - 虚拟dom->真实dom： 组件的信息在编译过程中被转换为真实的 DOM。Vue 在挂载组件时，会先将组件的虚拟 DOM 编译为 JavaScript 代码，再执行该代码以生成真实的 DOM。编译过程中，Vue 会考虑组件的模板、数据、事件等信息，并将其映射到真实的 DOM 元素上。这样，组件的信息就可以通过真实的 DOM 展示到页面上，并对用户交互做出反应。
   - onMounted时间点：Vue 的 `onMounted` 钩子函数在组件被挂载完成之后执行。也就是说，组件的虚拟 DOM 已经被编译为真实的 DOM，并与页面上的 DOM 元素对应起来，组件已经可以对页面上的元素进行操作。`onMounted` 钩子函数可以让我们在组件挂载完成后执行一些操作，==比如请求数据、初始化组件状态等==。

   通过以上的内容，可知可在onMounted中对页面上已经存在的图表dom进行操作，也就是在这里对`resize`事件进行一个监听

2. 对`unMounted`的理解

   - 当组件被卸载时，Vue 将会调用 `unmounted` 钩子函数。在该阶段，组件的实例已经不再被需要，并且已经从页面中删除了。==在该阶段，可以执行一些清理操作，如移除事件监听器，清除定时器等，以保证不会对其他组件造成影响==。

   也就是在这个页面组件上由开发者添加的任何监听器，定时器等统一在此处清理。

3. 对事件清理的理解

   当某个组件被卸载时，在它上面安装的监听器也应该被移除，否则当大量的监听器都没能及时清除的时候可能会导致内存的泄漏
