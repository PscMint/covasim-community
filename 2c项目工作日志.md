## 周一 0102

### 前端

工作内容：搭建项目，创建注册页面，实现mock的用户添加流程

知识点：

- 搭建项目的流程：vite命令创建新项目文件，选择框架和编程语言，新项目下安装相关依赖

- 页面：使用element-ui，main.js引入样式表，use将elementPlus的内容绑定到vue上

- mock流程下的添加用户请求流程：

  1. config：当前环境，当前环境下的mockBaseUrl和baseUrl（来自后台）

  2. 对于axios的二次封装，创建request类：

     service对象创建

     service绑定请求前和请求后的拦截器，主要用来设置请求头和处理响应拿到的内容

     request封装service，主要是将一些请求属性（比如请求方式，baseUrl，post的params等）整理了之后传给service并返回service

  3. mock拦截器设置：绑定url需要调用的模拟后台方法

  4. 增加用户的api，创建对应的request对象

  5. 绑定该api到具体的组件上

bug：reactive和ref的使用

### 后台

工作内容：连接数据库，实现数据库迁移，User数据表创建，User数据访问接口创建：get查询所有用户，post新增用户

## 周三 0104

### 后台

工作内容：

1. 确定了创建的sim的三类字典`sim_pars`,`int_pars`,`epi_pars`，并且对于传入参数进行了规范
2. 对于参数进行了解析，创建了相应的模拟并运行出结果
3. 确定了请求模拟结果的接口`sim_res`，同时给定了返回数据的json格式

### 前端

工作内容：

1. 设定了请求sim模拟数据的api
2. 创建了工作平台的主页面
3. 使用echart对后台的数据进行了基本的渲染

知识点：echart绘制层叠折线图

基本上来说，掌握了这个字典和其中字段的含义，就可以制作出不同数据下的层叠折线图

1. 配置字典，在vue中属于响应式数据

   ```js
   let Options=reactive({
       //图表标题+标题样式
                    title:{
                       text:"",
                       textStyle: {
                           fontFamily:"宋体",
                           fontWeight: 'bold',
                           color: '#17b3a3'
                           
                       }
                    },
       //图例
                    legend:{
                        //序列名称数组
                           data:['cum_death','cum_critical'],
                           bottom:10,
                           textStyle:{
                           color:"#17b3a3",
                           },  
                       },
       //提示框
                   tooltip:{
                       trigger:'axis'
                   },
       //x轴序列+x轴样式
   
                   xAxis: {
                          
                           data: [],
                           axisLine:{
                               lineStyle:{
                                   color:"#17b3a3"
                               }
                           }
                           },
       //y轴样式
                   yAxis: {
                      
                       axisLine:{
                           lineStyle:{
                               color:"#17b3a3"
                           }
                           }
                       
                   }, 
       //核心数据，每一组序列以对象的形式保存在series中
                   series:[],
               })
   ```

2. series的内容：每一组序列以对象的形式保存在series中，示例如下

   ```js
   series=[
       {
           type:"line",
           name:"cum_death",
           data:[0,0,0,...,0],
       },
       {
           type:"line",
           name:"cum_critical",
           data:[0,0,0,...,0],
       },
   ]
   ```

   通常需要把后台的数据处理成上述的结构，进行保存

3. 在页面上创建图标所对应的元素，元素需要有固定的宽高，并且基于上述配置渲染图表

   ```html
    <div ref="cum_echart" style="height:300px;"></div>
   ```

   ```js
   const cumChart=Echart.init(proxy.$refs["cum_echart"]);
   cumChart.setOption(xOptions);
   ```

   

## 周五 0106

### 前端

工作内容：

1. 设计模型参数表单

知识点：element-ui框架的表单制作、v-model

## 周六 0107

### 前端

工作内容：

1. 通过post表单提交sim_pars数据到后台，根据后台返回的数据实现页面渲染

### 后台

工作内容：

1. 增加了runSim方法`url:/run_sim`，当接收到表单的时候使用，把模型运行的结果返回给前端

## 周一 0116

### 前端

工作内容：

使用了element-ui的骨架组件给图表现实作加载处理

知识点：

基本使用思路

1. 骨架组件通过v-loading决定是否展现加载元素
2. 骨架组件可以插槽自定义一些加载背景
3. 骨架组件设有元素组件，可以用来选择合适的元素作为加载背景

## 周三-周四 0118-0119

### 前端

工作内容：

同一张图表的数据通过按钮请求新的数据从而刷新，在新的图表展示前做一个加载动画

1. 图表声明为响应式的，会导致echart中`tooltip:{trigger:'axis'}`失灵不展示，比较好的处理还是不要将图表声明为响应式

2. 直接把图表在setup中做初始化，会因为页面没有创建dom元素而报错，所以使用钩子`onMounted`，等页面渲染完成在这里做初始化

3. 运行时，要清空上一轮图表的数据，打开加载动画，之后拿到新的数据进行渲染，关闭加载动画，如此反复

4. 加载动画还是选择了element-plus的很多组件自带的loading相关指令，方便好用，同时可以多次调用

   下面是我的解决方案代码示例

   1. 图表容器+loading指令

   ```html
   <el-card shadow="hover" v-loading="loading" element-loading-text="运行中...">
                   <div ref="cum_echart" style="height:300px;">  
                   </div>
   </el-card>
   ```

   2. 运行处理程序

   ```js
   //初始化累计和新增折线图
       let cumChart=null
       let newChart=null
       onMounted(()=>{
           cumChart=Echart.init(proxy.$refs["cum_echart"]);
           newChart=Echart.init(proxy.$refs["new_echart"]);
       })
    const onRun=()=>{
           //清空上一轮页面渲染的内容
           if(cumChart)
               cumChart.clear();
           if(newChart)
               newChart.clear();
          
           //打开加载页面动画，保证用户体验
            loading.value=true
            
           
            proxy.$api.addNewRun(all_pars).then((res)=>{
               //处理请求数据...
        		//使用请求数据渲染...
               //渲染结束后取消加载动画
               loading.value=false;
            }
            )
            
       }
   ```

   
